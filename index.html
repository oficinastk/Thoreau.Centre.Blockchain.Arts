<html>
<head>

  <title>Thoreau Centre for the Blockchain Arts - Collection</title>
  
  <meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7; IE=EmulateIE9">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <!-- jquery and lazysizes -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js"></script>

  <!-- bootstrap (cards) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" type="text/css" rel="stylesheet" media="all">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js"></script>
  
  <!-- masonry -->
  <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.js"></script>
  <script src="https://unpkg.com/imagesloaded@5/imagesloaded.pkgd.min.js"></script>

  <!-- graphql -->
  <!-- <script type="module" src="https://cdn.jsdelivr.net/npm/graphql@16.8.1/index.min.js"></script> -->

  <style>
	

    .grid-sizer,
    .grid-item {
      width: 100%;
    }
	
    .grid-item {
      float: left;
      overflow: hidden;
      margin-bottom: 2%;
    }

    .gutter-sizer {
	
	
      width: 2%;
    }

    .grid-item .media {
      display: block;
      width: 100%
    }

    @media screen and (min-width: 768px) {
      /* 5 columns for larger screens */
      .grid-sizer, .grid-item { width: 32%; }
    }
	
	  @media screen and (min-width: 1200px) {
      /* 5 columns for larger screens */
      .grid-sizer, .grid-item { width: 23.5%; }
    }
	
	
    /*  --  */
    
    a:link {
      color: white;
    }	

    body {
	  background: linear-gradient(161deg,#f1e600,#f9f9f4,#040403);
	  background-size: 180% 180%;
	  animation: gradient-animation 15s ease infinite;
    }
	
    @keyframes gradient-animation {
      0% {
      background-position: 0% 50%;
      }
      50% {
      background-position: 100% 50%;
      }
      100% {
      background-position: 0% 50%;
      }
    }
    
    .card {
      background: #FFFFFF;
      border: #FFFFFF;
      max-width: 100%;
    }
    
    .card-text {
      color: #5db2e1;
      font-family: "Monaco", monospace;
      overflow-wrap: break-word;
      word-wrap: break-word;
      word-break: break-all;
      hyphens: auto;
    }
    
    .card-title {
      color: #5db2e1;
      font-family: "Monaco", monospace;
      margin-top: 5px;
      overflow-wrap: break-word;
      word-wrap: break-word;
      word-break: break-all;
      hyphens: auto;
    }
    
    .card-body {
      margin: 0px;
    }

    /* margem da imagem */
    #media {
      margin: 3%
    }

  </style>

    
</head>
<body>


  <div class="container-fluid pt-3 pl-3 pr-3 pb-3">
    <div class="grid" id="main">
      <div class="grid-sizer"></div>
      <div class="gutter-sizer"></div> 
      <div class="grid-item">
        <div class="card">
        <div class="card-body">
          <h5 class="card-title">TCBA Collection</h5>
          <p>The Thoreau Centre for the Blockchain Arts is firmly dedicated to show the works of artists using Ethereum and Tezos blockchains as their medium of creation or distribution. It stands proudly as one of the most diverse and inclusive collections displaying both established and non-established artists from all walks, as well as one of the oldest 'institutions' in the NFT space.
		  </p>
            <p>Read more about this project 
            <a href="https://github.com/oficinastk/Thoreau.Centre.Blockchain.Arts">here</a>.          
            <br>
          </p>
          <p style="font-size:80%;">
            Assets are (mostly) stored on IPFS and Arweave so please wait a moment for them to load :)
	<br> We are using ZORA API and Tzkt API to retrieve the NFTs, which are stored on a hardware wallet donated by Trezor
          </p>
        </div>
        </div>
      </div>
    </div>
  </div>

  

  <script>

    function paginated_fetch(url = is_required("url"), params, myHeaders, previousResponse = []) {
      return fetch(url + params.toString(), myHeaders) // Append the page number to the base URL
        .then(response => response.json())
        .then(newResponse => {
          // console.log(newResponse)
          console.log(newResponse)
          const response = [...previousResponse, ...newResponse['result']]; // Combine the two arrays

          if (newResponse['hasNextPage']) {
            
            params.set('cursor', newResponse['hasNextPage'])
            console.log(params.toString())
            return paginated_fetch(url, params, myHeaders, response);

          }
          return response;

        })
      }
    // import ZDK from '@zoralabs/zdk';

    const banned_eth_contracts = [
      '0xdfa1b0e237ab8b5a014e5180cba68ac19accc2bf',
      '0x61a9ea5ec7406b0cc34e9ac19bf90e204e4898d3',
      '0x92b971d307ebfc7331c23429e204a5e4adf7a833',
      '0x61d38d44e6c2397e4316018144911a77021104a6',
      '0xdbbf1b941e5864e8fdb4f6e0b309ae2ec9459bbf'
    ]


    // async function getMoralis(grid) {

    //   const ethAddress = '0x7CE438Bf068c8F47F0F46cB7891Fc7fD0956f117'

    //   // Replace with your Alchemy API key:
    //   const apiKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub25jZSI6IjQzMjNlNGVlLTc3NWYtNGRlMy05ZTY4LTY4ZGNiY2U2ODcyZiIsIm9yZ0lkIjoiNTg2MTAiLCJ1c2VySWQiOiI1ODI1OSIsInR5cGVJZCI6IjFjYzY1MjE0LTYzNWQtNGQzNy05ZDJiLWM1MDUwZjFlN2Y3NiIsInR5cGUiOiJQUk9KRUNUIiwiaWF0IjoxNjk1NDEwMTE4LCJleHAiOjQ4NTExNzAxMTh9.E44-c4EVJmmweRicI2bhQwP3B6Seo4MQUaP0DHyvz1s';
    //   const fetchURL = `https://deep-index.moralis.io/api/v2.2/${ethAddress}/nft?`;

    //   // Replace with the wallet address you want to query:
      
    //   // Replace with the token contract address you want to query:
    //   // const tokenAddr = "0x607f4c5bb672230e8672085532f7e901544a7375";

    //   const options = {
    //     method: 'GET', 
    //     headers: {
    //       'X-API-Key': apiKey,
    //       'accept': 'application/json'
    //     }};

    //   const params = new URLSearchParams({
    //     // owner_addresses: ethAddress,
    //     // limit: 5
    //     chain: 'eth'
    //     })

    //   paginated_fetch(fetchURL, params, options, []).then(assets => {
    //     console.log(assets)

    //     console.log(res)
    //     let contractList = []
    //     let contractDict = {}
    //     assets.forEach(token => {
          
    //       nft = token

    //       if (nft.collectionAddress in banned_eth_contracts) return 
    //       contractDict[nft.collectionAddress] = nft
    //       contractList.push(nft.collectionAddress)

    //       let img_url = null
    //       let type = null
    //       if (nft.content) {
    //         if (nft.content.url) {
    //           img_url = nft.content.url
    //           type = nft.content.mimeType
    //         }
    //       }

    //       if (!img_url && nft.image) {
    //         if (nft.image.url) {
    //           img_url = nft.image.url
    //           type = nft.image.mimeType
    //         }
    //       }

    //       if (img_url) {

    //         if (img_url.includes('arweave')) {
    //           // console.log(nft)
    //           // console.log(nft.name)
    //           // console.log(type)
              
    //         }
    //         name = nft.name
    //         artist_name = nft.mintInfo ? nft.mintInfo.originatorAddress : ''
    //         creation_date = nft.mintInfo ? new Date(nft.mintInfo.mintContext.blockTimestamp).getFullYear() : ''

    //         doCard(img_url, type, name, artist_name, creation_date, grid)
    //       }

          
    //     });

    //     const uniqueContracts = new Set(contractList)
    //     console.log(uniqueContracts)
    //     const uniqueNfts = contractDict[uniqueContracts]
    //     console.log(uniqueNfts)

    //   })

    // }


    // class NFT{

    //   constructor(object) {

    //     // console.log(object)
    //     this.collectionAddress = object.collectionAddress
    //     this.tokenId = object.tokenId
    //     this.name = object.name
    //     this.owner = object.owner
    //     this.content = {
    //       url: object.content.url,
    //       mimeType: object.content.mimeType
    //     }
    //     this.image = {
    //       url: object.image.url,
    //       mimeType: object.image.mimeType
    //     }
    //     this.metadata = object.metadata
    //     this.mintInfo = {
    //       originatorAddress: object.mintInfo.originatorAddress,
    //       mintContext: {
    //         blockTimestamp: object.mintInfo.mintContext.blockTimestamp
    //       }
    //     }

    //     // Object.assign(this, object);
    //   }

    // }


    async function getZora(grid) {

      

// fetch(`${fetchURL}/getNFTsForOwner?owner=${ethAddress}&withMetadata=true&pageSize=100`, options)
//   .then(response => response.json())
//   .then(response => console.log(response))
//   .catch(err => console.error(err));

      // const options = {method: 'POST', headers: {accept: 'application/json'}};
 
      // const ethAddress = '0x7CE438Bf068c8F47F0F46cB7891Fc7fD0956f117'
      // const alchemyURL = 'https://eth-mainnet.g.alchemy.com/v2/kh9TN_pTl-ANYxxkmcmlDrVwjgdsULX-'
      // fetch(`${alchemyURL}/alchemy_getTokenBalances?owner=${ethAddress}&pageSize=100&withMetadata=true`, options)
      // .then(response => response.json())
      // .then(response => console.log(response))
      // .catch(err => console.error(err));


      const ethAddress = '0x7CE438Bf068c8F47F0F46cB7891Fc7fD0956f117'
      const zora_api_url = "https://api.zora.co/graphql?query=";

      query = JSON.stringify({
        query: `query NFTs {
          tokens(
            networks: [{network: ETHEREUM, chain: MAINNET}]
            pagination: {limit: 300}
            where: {ownerAddresses: "thoreaucentre.eth"}
          ) {
            nodes {
              token {
                collectionAddress
                tokenId
                name
                owner
                content {
                  url
                  mimeType
                }
                image {
                  url
                  mimeType
                }
                metadata
                mintInfo {
                  originatorAddress
                  mintContext {
                    blockTimestamp
                  }
                }
              }
            }
          }
        }`
      })


      fetch(zora_api_url, {
        method: 'POST',
        headers: {
          "Content-Type": "application/json"
        },
        body: query
      })
      .then(res => res.json())
      .then(res => {

        console.log(res)

        // res.data.tokens.nodes.sort((a,b) => (a.collectionAddress > b.collectionAddress) ? 1 : ((b.collectionAddress > a.collectionAddress) ? -1 : 0))
        // const jsonDataTokens = JSON.stringify(res.data.tokens.nodes, null, 2)
        // download(jsonDataTokens, `allNFTs.txt`, 'text/plain');

        // let contractList = []
        // let contractDict = {}
        // let brokenNFTs = []
        res.data.tokens.nodes.forEach(token => {
          
          const nft = token.token

          if (nft.collectionAddress in banned_eth_contracts) return 
          // contractDict[nft.collectionAddress] = nft
          // contractList.push(nft.collectionAddress)

          let img_url = null
          let type = null
          if (nft.content) {
            if (nft.content.url) {
              img_url = nft.content.url
              type = nft.content.mimeType
            }
          }

          if (!img_url && nft.image) {
            if (nft.image.url) {
              img_url = nft.image.url
              type = nft.image.mimeType
            }
          }

          if((!img_url) && nft.metadata) {

            if('imgUrl' in nft.metadata) {
              img_url = nft.metadata.imgUrl
            }

            if('imageUrl' in nft.metadata) {
              img_url = nft.metadata.imageUrl
            }

            if(nft.metadata.image) {
              img_url = nft.metadata.image
            }

            if(nft.metadata.url) {
              img_url = nft.metadata.url
            }

          }

          // para OG:crystal
          if(img_url) {
            if(img_url.includes('animation') & !type) {
              type = 'video'
            }
          }
          

          

          const name = nft.name
          const artist_name = nft.mintInfo ? nft.mintInfo.originatorAddress : ''
          const creation_date = nft.mintInfo ? new Date(nft.mintInfo.mintContext.blockTimestamp).getFullYear() : ''

          // para winter solstice
          if(name) {
            if(name.includes('Solstice') & !type) {
              type = 'video'
            }

            if(name.includes('Pope')) {
              type = 'image'
            }
          }
          

          if(artist_name == ethAddress & nft.metadata) {
            console.log(nft.metadata)
          } 


          if (img_url) {

            if (img_url.includes('arweave')) {
              // console.log(nft)
              // console.log(nft.name)
              // console.log(type)
              
            }

            doCard(img_url, type, name, artist_name, creation_date, grid)
          }


          // // guardar tipo de metadata
          // if(!name || !artist_name || !creation_date || !img_url || !type) {
          //   if(nft.metadata) {
          //     const brokenNFT = {
          //     collectionAddress: nft.collectionAddress,
          //     name: name,
          //     artist_name: artist_name,
          //     creation_date: creation_date,
          //     img_url: img_url,
          //     type: type,
          //     metadata: nft.metadata
          //   }
          //   brokenNFTs.push(brokenNFT)
          //   }
          // }

          
        });

        // brokenNFTs.sort((a,b) => (a.collectionAddress > b.collectionAddress) ? 1 : ((b.collectionAddress > a.collectionAddress) ? -1 : 0))
        // const jsonData = JSON.stringify(brokenNFTs, null, 2)
        // download(jsonData, `brokenNFTs.txt`, 'text/plain');

      })        

    }


    function download(content, fileName, contentType) {
      var a = document.createElement("a");
      var file = new Blob([content], {type: contentType});
      a.href = URL.createObjectURL(file);
      a.download = fileName;
      a.click();
    }


    async function getTezos(grid) {

      const tezos_url = 'https://api.tzkt.io/'
      const tezos_address = 'tz1MkJT1ZpqmTzvS9QFJSa4GpaLNRyRaLCYd'
      const query = `v1/tokens/balances?account=${tezos_address}&limit=1000`
      const url = tezos_url + query
      

      await fetch(url).then(function(response) {
        return response.json();
      }).then(function(data) {
        
        // console.log(data)
        for (let i = 0; i < data.length; i++) {

          creation_date = new Date(data[i]['firstTime']).getFullYear()
          token = data[i]['token']
          meta = token['metadata']
          if (meta) {

            token_url = meta['artifactUri']
            artist = meta['creators']
            name = meta['name']

            if ('formats' in meta) {
              type = meta['formats'][0]['mimeType']
            } 
            
            if (token_url) {
              doCard(token_url, type, name, artist, creation_date, grid)
            }
          }
          
          
        }
      }).catch(function(err) {
        console.log(err);
      });

    }



    function fixURL2(url){
      
      // console.log(url)
      if(url.startsWith("ipfs://ipfs")){
        return "https://ipfs.io/ipfs/"+url.split("ipfs://ipfs/").slice(-1)[0];
      } else if (url.startsWith("ipfs://")) {
        return "https://ipfs.io/ipfs/"+url.split("ipfs://").slice(-1)[0];
      } else if (url.includes('infura')) {
        return url.replace('infura.', '')
      } else if (url.includes('daonomic.com')) {
        return url.replace('daonomic.com', 'io')
      } else {
        return url
      }
    }


    function doCard(url, type, name, artist, creation_date, $grid) {
  
      const gridItem = document.createElement("div");
      gridItem.className = "grid-item";

      const gridItemContent = document.createElement("div");
      gridItemContent.className = "grid-item-content";

      const card = document.createElement("div");
		  card.className = "card";

      const cardBody = document.createElement("div");
		  cardBody.className = "card-body";

      const div = document.createElement("div");

      const title = document.createElement("h5");
		  title.className = "card-title";
      title.textContent = name

      const text = document.createElement("p");
		  text.className = "card-text";
      text.textContent = artist     
	
      const date = document.createElement("p");
		  date.className = "card-text";
      date.textContent = creation_date 

      const a_el = document.createElement("a");
      a_el.setAttribute('href', fixURL2(url))
      a_el.setAttribute('id', 'media')

      const grid = document.getElementById('main');
      grid.appendChild(gridItem)
      gridItem.appendChild(gridItemContent)
      gridItemContent.appendChild(card)

      card.appendChild(cardBody)
      cardBody.appendChild(div)
      div.appendChild(title)
      div.appendChild(text)
      div.appendChild(date)

      card.appendChild(a_el)
      
   

      let media = null
      if (type) {
        if (type.startsWith('image')) {

          media = document.createElement("img");
          a_el.appendChild(media);

        } else if (type.startsWith('video')) {

          media = document.createElement("video");
          media.setAttribute('loop', 'true')
          media.controls = true;
          media.autoplay = true;
          media.muted = true;
          a_el.appendChild(media);

        } else if (type.startsWith('application')) {

          media = document.createElement("embed")
          media.type = type
          a_el.appendChild(media);

        } else if (type.startsWith('text')) {

          media = document.createElement("iframe")
          a_el.appendChild(media);

        }
      } else {
        // assume que e imagem
        media = document.createElement("img");
        a_el.appendChild(media);
      }
      

      if (media != null) {

        media.setAttribute('data-src', fixURL2(url))
        // media.setAttribute('src', 'imagens/loading.svg')
		    media.setAttribute('src', 'https://raw.githubusercontent.com/oficinastk/oficinastk.github.io/master/TCBA/loading.svg')
        media.className = 'lazyload media'
      }
      
      $grid.append(gridItem).masonry('appended', gridItem);

    }



    // -------------- MAIN -------------- \\

    const $grid = $('.grid').masonry({
          itemSelector: '.grid-item',
          gutter: '.gutter-sizer',
          columnWidth: '.grid-sizer',
          percentPosition: true,
          horizontalOrder: true
        })


    // get eth nfts
    // getMoralis($grid)
    getZora($grid)

    // get tezos nfts
    getTezos($grid)

    // layout Masonry after each image loads
    $grid.imagesLoaded().progress( function() {
      $grid.masonry('layout');
    });


    $('.grid').each(function(){
      var $module = $(this);
      var update = function(){
        $module.masonry('layout');
      };

      this.addEventListener('load', update, true);

      $module.masonry();
    });




  </script>
</body>
</html>
