<html>
<head>

  <title>Thoreau Centre for the Blockchain Arts - Collection</title>
  
  <meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7; IE=EmulateIE9">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <!-- jquery and lazysizes -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js"></script>

  <!-- bootstrap (cards) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" type="text/css" rel="stylesheet" media="all">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js"></script>
  
  <!-- masonry -->
  <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.js"></script>
  <script src="https://unpkg.com/imagesloaded@5/imagesloaded.pkgd.min.js"></script>

  <!-- graphql -->
  <!-- <script type="module" src="https://cdn.jsdelivr.net/npm/graphql@16.8.1/index.min.js"></script> -->

  <style>
	

    .grid-sizer,
    .grid-item {
      width: 100%;
    }
	
    .grid-item {
      float: left;
      overflow: hidden;
      margin-bottom: 2%;
    }

    .gutter-sizer {
	
	
      width: 2%;
    }

    .grid-item .media {
      display: block;
      width: 100%
    }

    @media screen and (min-width: 768px) {
      /* 5 columns for larger screens */
      .grid-sizer, .grid-item { width: 32%; }
    }
	
	  @media screen and (min-width: 1200px) {
      /* 5 columns for larger screens */
      .grid-sizer, .grid-item { width: 23.5%; }
    }
	
	
    /*  --  */
    
    a:link {
      color: white;
    }	

    body {
	  background: linear-gradient(161deg,#f1e600,#f9f9f4,#040403);
	  background-size: 180% 180%;
	  animation: gradient-animation 15s ease infinite;
    }
	
    @keyframes gradient-animation {
      0% {
      background-position: 0% 50%;
      }
      50% {
      background-position: 100% 50%;
      }
      100% {
      background-position: 0% 50%;
      }
    }
    
    .card {
      background: #FFFFFF;
      border: #FFFFFF;
      max-width: 100%;
    }
    
    .card-text {
      color: #5db2e1;
      font-family: "Monaco", monospace;
      overflow-wrap: break-word;
      word-wrap: break-word;
      word-break: break-all;
      hyphens: auto;
    }
    
    .card-title {
      color: #5db2e1;
      font-family: "Monaco", monospace;
      margin-top: 5px;
      overflow-wrap: break-word;
      word-wrap: break-word;
      word-break: break-all;
      hyphens: auto;
    }
    
    .card-body {
      margin: 0px;
    }

    /* margem da imagem */
    #media {
      margin: 3%
    }

  </style>

    
</head>
<body>


  <div class="container-fluid pt-3 pl-3 pr-3 pb-3">
    <div class="grid" id="main">
      <div class="grid-sizer"></div>
      <div class="gutter-sizer"></div> 
      <div class="grid-item">
        <div class="card">
        <div class="card-body">
          <h5 class="card-title">TCBA Collection</h5>
          <p>The Thoreau Centre for the Blockchain Arts is firmly dedicated to show the works of artists using Ethereum and Tezos blockchains as their medium of creation or distribution. It stands proudly as one of the most diverse and inclusive collections displaying both established and non-established artists from all walks, as well as one of the oldest 'institutions' in the NFT space.
		  </p>
            <p>Read more about this project 
            <a href="https://github.com/oficinastk/Thoreau.Centre.Blockchain.Arts">here</a>.          
            <br>
          </p>
          <p style="font-size:80%;">
            Assets are (mostly) stored on IPFS and Arweave so please wait a moment for them to load :)
	<br> We are using ZORA API and Tzkt API to retrieve the NFTs, which are stored on a hardware wallet donated by Trezor
          </p>
        </div>
        </div>
      </div>
    </div>
  </div>

  

  <script type="module">

    // import { ethers } from "https://cdnjs.cloudflare.com/ajax/libs/ethers/6.8.0/ethers.js";
    // import { ethers } from "https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.min.js";
    // const provider = ethers.getDefaultProvider()
  
    // console.log(ethers)
    // import { ethers } from "https://cdn-cors.ethers.io/lib/ethers-5.7.esm.min.js";

    function paginated_fetch(url = is_required("url"), params, myHeaders, previousResponse = []) {
      return fetch(url + params.toString(), myHeaders) // Append the page number to the base URL
        .then(response => response.json())
        .then(newResponse => {
          // console.log(newResponse)
          console.log(newResponse)
          const response = [...previousResponse, ...newResponse['result']]; // Combine the two arrays

          if (newResponse['hasNextPage']) {
            
            params.set('cursor', newResponse['hasNextPage'])
            console.log(params.toString())
            return paginated_fetch(url, params, myHeaders, response);

          }
          return response;

        })
      }
    // import ZDK from '@zoralabs/zdk';

    


    // async function getMoralis(grid) {

    //   const ethAddress = '0x7CE438Bf068c8F47F0F46cB7891Fc7fD0956f117'

    //   // Replace with your Alchemy API key:
    //   const apiKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub25jZSI6IjQzMjNlNGVlLTc3NWYtNGRlMy05ZTY4LTY4ZGNiY2U2ODcyZiIsIm9yZ0lkIjoiNTg2MTAiLCJ1c2VySWQiOiI1ODI1OSIsInR5cGVJZCI6IjFjYzY1MjE0LTYzNWQtNGQzNy05ZDJiLWM1MDUwZjFlN2Y3NiIsInR5cGUiOiJQUk9KRUNUIiwiaWF0IjoxNjk1NDEwMTE4LCJleHAiOjQ4NTExNzAxMTh9.E44-c4EVJmmweRicI2bhQwP3B6Seo4MQUaP0DHyvz1s';
    //   const fetchURL = `https://deep-index.moralis.io/api/v2.2/${ethAddress}/nft?`;

    //   // Replace with the wallet address you want to query:
      
    //   // Replace with the token contract address you want to query:
    //   // const tokenAddr = "0x607f4c5bb672230e8672085532f7e901544a7375";

    //   const options = {
    //     method: 'GET', 
    //     headers: {
    //       'X-API-Key': apiKey,
    //       'accept': 'application/json'
    //     }};

    //   const params = new URLSearchParams({
    //     // owner_addresses: ethAddress,
    //     // limit: 5
    //     chain: 'eth'
    //     })

    //   paginated_fetch(fetchURL, params, options, []).then(assets => {
    //     console.log(assets)

    //     console.log(res)
    //     let contractList = []
    //     let contractDict = {}
    //     assets.forEach(token => {
          
    //       nft = token

    //       if (nft.collectionAddress in banned_eth_contracts) return 
    //       contractDict[nft.collectionAddress] = nft
    //       contractList.push(nft.collectionAddress)

    //       let img_url = null
    //       let type = null
    //       if (nft.content) {
    //         if (nft.content.url) {
    //           img_url = nft.content.url
    //           type = nft.content.mimeType
    //         }
    //       }

    //       if (!img_url && nft.image) {
    //         if (nft.image.url) {
    //           img_url = nft.image.url
    //           type = nft.image.mimeType
    //         }
    //       }

    //       if (img_url) {

    //         if (img_url.includes('arweave')) {
    //           // console.log(nft)
    //           // console.log(nft.name)
    //           // console.log(type)
              
    //         }
    //         name = nft.name
    //         artistName = nft.mintInfo ? nft.mintInfo.originatorAddress : ''
    //         creation_date = nft.mintInfo ? new Date(nft.mintInfo.mintContext.blockTimestamp).getFullYear() : ''

    //         doCard(img_url, type, name, artistName, creation_date, grid)
    //       }

          
    //     });

    //     const uniqueContracts = new Set(contractList)
    //     console.log(uniqueContracts)
    //     const uniqueNfts = contractDict[uniqueContracts]
    //     console.log(uniqueNfts)

    //   })

    // }


    // class NFT{

    //   constructor(object) {

    //     // console.log(object)
    //     this.collectionAddress = object.collectionAddress
    //     this.tokenId = object.tokenId
    //     this.name = object.name
    //     this.owner = object.owner
    //     this.content = {
    //       url: object.content.url,
    //       mimeType: object.content.mimeType
    //     }
    //     this.image = {
    //       url: object.image.url,
    //       mimeType: object.image.mimeType
    //     }
    //     this.metadata = object.metadata
    //     this.mintInfo = {
    //       originatorAddress: object.mintInfo.originatorAddress,
    //       mintContext: {
    //         blockTimestamp: object.mintInfo.mintContext.blockTimestamp
    //       }
    //     }

    //     // Object.assign(this, object);
    //   }

    // }


    async function getZora(grid) {

      

// fetch(`${fetchURL}/getNFTsForOwner?owner=${ethAddress}&withMetadata=true&pageSize=100`, options)
//   .then(response => response.json())
//   .then(response => console.log(response))
//   .catch(err => console.error(err));

      // const options = {method: 'POST', headers: {accept: 'application/json'}};
 
      // const ethAddress = '0x7CE438Bf068c8F47F0F46cB7891Fc7fD0956f117'
      // const alchemyURL = 'https://eth-mainnet.g.alchemy.com/v2/kh9TN_pTl-ANYxxkmcmlDrVwjgdsULX-'
      // fetch(`${alchemyURL}/alchemy_getTokenBalances?owner=${ethAddress}&pageSize=100&withMetadata=true`, options)
      // .then(response => response.json())
      // .then(response => console.log(response))
      // .catch(err => console.error(err));


      const banned_eth_contracts = [
        '0xdfa1b0e237ab8b5a014e5180cba68ac19accc2bf',
        '0x61a9ea5ec7406b0cc34e9ac19bf90e204e4898d3',
        '0x92b971d307ebfc7331c23429e204a5e4adf7a833',
        '0x61d38d44e6c2397e4316018144911a77021104a6',
        '0xdbbf1b941e5864e8fdb4f6e0b309ae2ec9459bbf',
        '0xb5833ba237fd1589c52129f713e5d93989c634b2',
        '0xa4c3c0dd20edc3962d1ca1f19a1b48507c331a12',
        '0x94d3e8ea9b76e99e3de52c41823c56eb03c000e7',
        '0x81dc9934094b65b704ba9388c27089dbe2c5fb6e',
        '0xd851fbd96d16d6b818c622cbc23e4197adce4058'
      ]

      const ethAddress = "0x7ce438bf068c8f47f0f46cb7891fc7fd0956f117"
      const zora_api_url = "https://api.zora.co/graphql?query=";

      const query = JSON.stringify({
        query: `query NFTs {
          tokens(
            networks: [{network: ETHEREUM, chain: MAINNET}]
            pagination: {limit: 300}
            where: {ownerAddresses: "thoreaucentre.eth"}
          ) {
            nodes {
              token {
                collectionAddress
                tokenId
                name
                owner
                content {
                  url
                  mimeType
                }
                image {
                  url
                  mimeType
                }
                metadata
                mintInfo {
                  originatorAddress
                  mintContext {
                    blockTimestamp
                  }
                }
              }
            }
          }
        }`
      })


      fetch(zora_api_url, {
        method: 'POST',
        headers: {
          "Content-Type": "application/json"
        },
        body: query
      })
      .then(res => res.json())
      .then(res => {

        console.log(res)

        // res.data.tokens.nodes.sort((a,b) => (a.collectionAddress > b.collectionAddress) ? 1 : ((b.collectionAddress > a.collectionAddress) ? -1 : 0))
        // const jsonDataTokens = JSON.stringify(res.data.tokens.nodes, null, 2)
        // download(jsonDataTokens, `allNFTs.txt`, 'text/plain');

        // let contractList = []
        // let contractDict = {}
        let brokenNFTs = []
        res.data.tokens.nodes.forEach(async (token, index) => {
          
          const nft = token.token

          // if(nft.name.includes('Fortune')) {console.log(nft)}

          if (banned_eth_contracts.includes(nft.collectionAddress)) return
          // contractDict[nft.collectionAddress] = nft
          // contractList.push(nft.collectionAddress)

          let img_url = null
          let type = null
          if (nft.content) {
            if (nft.content.url) {
              img_url = nft.content.url
              type = nft.content.mimeType
            }
          }

          if (!img_url && nft.image) {
            if (nft.image.url) {
              img_url = nft.image.url
              type = nft.image.mimeType
            }
          }

          if((!img_url) && nft.metadata) {

            if('imgUrl' in nft.metadata) {
              img_url = nft.metadata.imgUrl
            }

            if('imageUrl' in nft.metadata) {
              img_url = nft.metadata.imageUrl
            }

            if(nft.metadata.image) {
              img_url = nft.metadata.image
            }

            if(nft.metadata.url) {
              img_url = nft.metadata.url
            }

          }

          // para OG:crystal
          if(img_url) {
            // if(type.includes('text')) {console.log(nft)}
            if(img_url.includes('animation') & !type) {
              type = 'video'
            }
          }
          

          

          const name = nft.name
          let artistName = nft.mintInfo ? nft.mintInfo.originatorAddress : ""
          const creation_date = nft.mintInfo ? new Date(nft.mintInfo.mintContext.blockTimestamp).getFullYear() : ''

          // para winter solstice
          if(name) {
            if(name.includes('Solstice') & !type) {
              type = 'video'
            }

            if(name.includes('Pope')) {
              type = 'image'
            }
          }
          

          // console.log(artistName, ethAddress)
          // const artistNameNormalized = artistName.substr(0, artistName.indexOf("<")).trim();
          if(artistName === ethAddress) {
            artistName = changeArtistName(nft)
            // console.log(artistName)
          }

          // if(artistName) {
          //   // const mainnetProvider = new ethers.providers.JsonRpcProvider("https://eth-mainnet-public.unifra.io");
          //   possibleName = await provider.lookupAddress('0x378a29135fdFE323414189f682b061fc64aDC0B3');
          //   console.log(possibleName)
          //   if(possibleName) artistName = possibleName
          // }

          if (img_url) {
            doCard(img_url, type, name, artistName, creation_date, grid, 'eth', index)
          }


          // // guardar tipo de metadata
          // if(!name || !artistName || !creation_date || !img_url || !type) {
          //   if(nft.metadata) {
          //     const brokenNFT = {
          //     collectionAddress: nft.collectionAddress,
          //     name: name,
          //     artistName: artistName,
          //     creation_date: creation_date,
          //     img_url: img_url,
          //     type: type,
          //     metadata: nft.metadata
          //   }
          //   brokenNFTs.push(brokenNFT)
          //   }
          // }

          
        });

        // brokenNFTs.sort((a,b) => (a.collectionAddress > b.collectionAddress) ? 1 : ((b.collectionAddress > a.collectionAddress) ? -1 : 0))
        // const jsonData = JSON.stringify(brokenNFTs, null, 2)
        // download(jsonData, `brokenNFTs.txt`, 'text/plain');

      })        

    }


    function changeArtistName(nft) {

      let artistName = nft.collectionAddress
      // if(nft.name.includes('Pooly')) {console.log(nft); artistName = 'Pooly'; return artistName}
      // if(nft.collectionAddress == '0x76dcaaf781cf28aa7fc7a4afbb919068936b7b35') {console.log(nft); artistName = nft.metadata.created_by; return artistName}
      // if(nft.collectionAddress == '0xd4a6669e4787f23a2f711e0b6c6fb5431ce1594e') {
      //   console.log(nft); 
      //   artistName = nft.metadata.attributes.find(obj => obj.trait_type == 'Artist').value
      //   return artistName
      // }
      return artistName
    }


    function download(content, fileName, contentType) {
      var a = document.createElement("a");
      var file = new Blob([content], {type: contentType});
      a.href = URL.createObjectURL(file);
      a.download = fileName;
      a.click();
    }


    async function getTezos(grid) {

      const tezos_url = 'https://api.tzkt.io/'
      const tezos_address = 'tz1MkJT1ZpqmTzvS9QFJSa4GpaLNRyRaLCYd'
      const query = `v1/tokens/balances?account=${tezos_address}&limit=1000`
      const url = tezos_url + query
      

      let addresses = {}
      await fetch(url)
      .then(response => {
        return response.json();
      })
      .then(async data => {
        
        // console.log(data)
        for (let i = 0; i < data.length; i++) {

          const creation_date = new Date(data[i]['firstTime']).getFullYear()
          const token = data[i]['token']
          const meta = token['metadata']
          if (meta) {

            const token_url = meta['artifactUri']
            const name = meta['name']

            const artist = meta['creators']
            if(artist in addresses) {
              addresses[artist].push(i)
            } else {
              addresses[artist] = [i]
            }
            
            // const profile = await getTzProfile(meta['creators'])
            // const artist = profile.exists ? profile.alias : meta['creators']
            
            let type = null
            if ('formats' in meta) {
              type = meta['formats'][0]['mimeType']
            } 
            
            if (token_url) {
              doCard(token_url, type, name, artist, creation_date, grid, 'tezos', i)
            }
          }
          
          
        }
      }).catch(function(err) {
        console.log(err);
      });

      return addresses

    }


    async function getTzProfile(address) {

      const url = `https://api.tzprofiles.com/${address}` 

      let profile = {exists: false, alias: ''}

      if(!address) return profile

      return await fetch(url)
      .then(response => {
        return response.json();
      })
      .then(data => {

        data.forEach((x) => {
            const obj = JSON.parse(x[1])
            const context = obj['@context'][1]
            const credentialSubject = obj['credentialSubject']

            if (typeof context != 'string') {
              if ('website' in context) {
                profile.alias = credentialSubject['alias']
                profile.exists = true
              }
            }
          
          })

        return profile

      })

    }



    function fixURL2(url){
      
      // console.log(url)
      if(url.startsWith("ipfs://ipfs")){
        return "https://ipfs.io/ipfs/"+url.split("ipfs://ipfs/").slice(-1)[0];
      } else if (url.startsWith("ipfs://")) {
        return "https://ipfs.io/ipfs/"+url.split("ipfs://").slice(-1)[0];
      } else if (url.includes('infura')) {
        return url.replace('infura.', '')
      } else if (url.includes('daonomic.com')) {
        return url.replace('daonomic.com', 'io')
      } else {
        return url
      }
    }


    function doCard(url, type, name, artist, creation_date, $grid, network, index) {
  
      const gridItem = document.createElement("div");
      gridItem.className = "grid-item";

      const gridItemContent = document.createElement("div");
      gridItemContent.className = "grid-item-content";

      const card = document.createElement("div");
		  card.className = "card";

      const cardBody = document.createElement("div");
		  cardBody.className = "card-body";

      const div = document.createElement("div");

      const title = document.createElement("h5");
		  title.className = "card-title";
      title.textContent = name

      const artistUrl = document.createElement("a")
      artistUrl.setAttribute('target', '_blank') 
      if(network == 'eth') {
        artistUrl.setAttribute('href', `https://etherscan.io/address/${artist}`) 
      } else {
        artistUrl.setAttribute('href', `https://tzkt.io/${artist}`) 
      }  

      const text = document.createElement("p");
		  text.className = "card-text";
      text.textContent = artist 
      text.setAttribute('id', `${network}${index.toString()}`)    
	
      const date = document.createElement("p");
		  date.className = "card-text";
      date.textContent = creation_date 

      const a_el = document.createElement("a");
      a_el.setAttribute('href', fixURL2(url))
      a_el.setAttribute('id', 'media')

      const grid = document.getElementById('main');
      grid.appendChild(gridItem)
      gridItem.appendChild(gridItemContent)
      gridItemContent.appendChild(card)

      card.appendChild(cardBody)
      cardBody.appendChild(div)
      div.appendChild(title)
      div.appendChild(artistUrl)
      artistUrl.appendChild(text)
      div.appendChild(date)

      card.appendChild(a_el)
      
   

      let media = null
      if (type) {
        if (type.startsWith('image')) {

          media = document.createElement("img");
          a_el.appendChild(media);

        } else if (type.startsWith('video')) {

          media = document.createElement("video");
          media.setAttribute('loop', 'true')
          media.controls = true;
          media.autoplay = true;
          media.muted = true;
          a_el.appendChild(media);

        } else if (type.startsWith('application')) {

          media = document.createElement("embed")
          media.type = type
          a_el.appendChild(media);

        } else if (type.startsWith('text')) {

          media = document.createElement("iframe")
          a_el.appendChild(media);

        }
      } else {
        // assume que e imagem
        media = document.createElement("img");
        a_el.appendChild(media);
      }
      

      if (media != null) {

        media.setAttribute('data-src', fixURL2(url))
        // media.setAttribute('src', 'imagens/loading.svg')
		    media.setAttribute('src', 'https://raw.githubusercontent.com/oficinastk/oficinastk.github.io/master/TCBA/loading.svg')
        media.className = 'lazyload media'
      }
      
      $grid.append(gridItem).masonry('appended', gridItem);

    }



    // -------------- MAIN -------------- \\

    const $grid = $('.grid').masonry({
          itemSelector: '.grid-item',
          gutter: '.gutter-sizer',
          columnWidth: '.grid-sizer',
          percentPosition: true,
          horizontalOrder: true
        })


    // get eth nfts
    getZora($grid)

    // get tezos nfts
    const artistAddresses = getTezos($grid)

    // TODO
    console.log(artistAddresses)
    // for(let address of artistAddresses.keys()) {

    //   console.log(address)
    //   const profile = await getTzProfile(address)
    //   if(profile.exists) {

    //     for(index in artistAddresses[address]) {
    //       const artistEl = document.getElementById(`tezos${index.toString()}`)
    //       console.log(artistEl)
    //       text.textContent = profile.alias
    //     }
        
    //   }
    //   const artist = profile.exists ? profile.alias : meta['creators']

    // }

    // layout Masonry after each image loads
    $grid.imagesLoaded().progress( function() {
      $grid.masonry('layout');
    });


    $('.grid').each(function(){
      var $module = $(this);
      var update = function(){
        $module.masonry('layout');
      };

      this.addEventListener('load', update, true);

      $module.masonry();
    });




  </script>
</body>
</html>
